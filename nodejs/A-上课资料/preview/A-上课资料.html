<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>itcastmark:D:\传智播客\讲义\第一天nodejs\A-上课资料\A-上课资料</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="nodejs">Nodejs</h1>
<h2 id="1-">1.如何去对待新的事物</h2>
<p>##.2.前端的发展史和趋势,</p>
<h3 id="1-">1.什么是前端</h3>
<p>前端：针对浏览器的开发，代码在浏览器运行
后端：针对服务器的开发，代码在服务器运行</p>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\frontend.png" alt=""></p>
<h3 id="2-">2.前后端不分的时代</h3>
<p>1.前后端不分的时代
互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。
前端负责后端开发的界面部分</p>
<p>2.前端工程师的角色
那时的前端工程师，实际上是模板工程师，负责编写页面模板。
后端代码读取模板，替换变量，渲染出页面。</p>
<p>3.典型的 PHP 模板</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;Car {{ $data-&gt;id }}&lt;/h1&gt;
&lt;/body&gt;
</code></pre><p>4.Ajax
前端不再是后端的模板，可以独立得到各种数据。
前端实现动态网页，富交互，负责数据处理</p>
<p>5.前后端分离
前端变成了一个完整的应用，后端提供接口服务</p>
<p>6.新的技术革命 Node.js
2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。
Node = JavaScript + 操作系统 API</p>
<p>JavaScript 成为服务器脚本语言，与 Python 和 javascript 一样
JavaScript 成为唯一的浏览器和服务器都支持的语言
前端工程师可以编写后端程序了</p>
<h2 id="3-node-js-">3.Node.js的起源</h2>
<p><strong>【重点】同步IO和异步IO</strong></p>
<p><strong>Node.js作者</strong></p>
<ol>
<li>Node.js的作者是Ryan Dahl，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</li>
</ol>
<p><strong>Node.js运行引擎</strong></p>
<p>这位仁兄曾考虑过自己写一个javascript运行引擎，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>浏览器大战的历史遗留问题</p>
<p>V8是由Google公司开发的一个高性能javascript解析引擎，目前chrome浏览器内置的javascript解析引擎就是V8</p>
<p><strong>Node.js诞生</strong>
于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p>
<h2 id="4-">4.大前端</h2>
<p><strong>全栈工程师</strong>
不想成为全栈的前端不是好程序员</p>
<p>为什么呢？随着现代大型互联网应用架构越趋复杂，一个人是很难同时精通
很多领域的，但如果只是开发小型应用，应对不多的流量，借助开源软件和工具，
一个人也可以办到，这是导致全栈工程师出现的根本原因</p>
<p>会一门前端和一门后端就自称是全程工程师了。没错，真的可以。</p>
<h2 id="5-node-js-">5.node.js使用场景</h2>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\20181108182244.png" alt=""></p>
<ol>
<li>跨平台：覆盖你能想到的面向用户的所有平台，传统的PCWeb端，以及PC
客户端nw.js/electron、移动端cordova、HTML5、react-native、weex等。</li>
<li>Web应用开发：网站、Api、RPC服务等。</li>
<li>前端：三大框架React\Vue\Angular辅助开发，以及工程化演进过程（使
用Gulp/Webpack构建Web开发工具）。</li>
<li>工具：npm上各种工具模块，包括各种前端预编译、构建工具Grunt/
Gulp、脚手架，命令行工具，各种奇技淫巧。</li>
</ol>
<h2 id="6-">6.常见的问答</h2>
<h2 id="7-node-js-">7.Node.js的下载安装</h2>
<p>1.Node.js下载
Node.js官网地址         <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>
Node.js中文网         <a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<p>Node.js下载地址        <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a>
下载历史版本         <a href="https://nodejs.org/zh-cn/download/releases/">https://nodejs.org/zh-cn/download/releases/</a></p>
<p>注意：
每个版本会存在一定的兼容性问题，尽量使用长期支持(LTS)版本    </p>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\node-install2.png" alt=""></p>
<p>2.Node.js安装</p>
<p>3.测试是否安装成功
在cmd窗口输入 <code>node -v</code>
成功打印出版本号再输入 <code>npm -v</code></p>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\node-install.png" alt=""></p>
<h2 id="9-node-js-javasccript-">9.在Node.js中执行javasccript代码</h2>
<p>在Node.js环境中执行代码两种方法</p>
<p><strong>1.在cmd窗口输入 <code>node</code> 进入node编辑器</strong></p>
<ul>
<li>输入 <code>console.log(123)</code> 查看输入结果</li>
<li>输入 <code>1+2</code> 查看输出结果</li>
</ul>
<p><strong>2.在cmd窗口使用node命令执行js文件</strong></p>
<ul>
<li>切换到文件目录文件夹下  <code>cd [文件夹路径]</code></li>
<li>在cmd窗口输入 <code>node [js文件名]</code></li>
</ul>
<p>###【重点】浏览器端的javascript和Node.js中的JavaScript</p>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\20181108172720.png" alt=""></p>
<p>1.浏览器中的JavaScript的全局对象是window, 而nodejs中全局对象是global
2.nodejs中的javascript没有DOM和BOM
3.浏览器javascript和nodejs支持的标准不一样,如(Promise)</p>
<h2 id="10-ecmascript-">10.关于ECMAScript标准</h2>
<p>1.什么是ECMAScript标准?</p>
<p>2.ECMAScript的发展史</p>
<p>3.ECMAScript标准目前支持情况?
目前浏览器只能支持部分ECMAscript6的属性，而最新版本的nodejs能完美支持几乎所有属性</p>
<h2 id="11-es6-var-let-const">11.【重点】ES6-声明变量命令 var、let、const</h2>
<h3 id="1-let-">1.let命令</h3>
<p><strong>什么是let命令？</strong>
let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
<strong>let命令的特点</strong>
1.let为javascript新增了块级作用域
2.let声明的变量只在它所在的代码块有效,if和for循环都属于代码块
3.var声明会存在变量提升，let声明不存在变量提升
4.let不允许重复声明变量</p>
<h3 id="2-const-">2.const命令</h3>
<p><strong>什么是const命令</strong>
const声明一个只读的常量。一旦声明，常量的值就不能改变。
<strong>const命令的特点</strong>
1.const声明的变量不得改变值
2.const不能只声明不赋值
3.const的作用域与let命令相同：只在声明所在的块级作用域内有效
<strong>注意</strong>
如果使用const声明一个对象或者数组，该对象和数组是可以内部属性的</p>
<h2 id="12-es6-">12.ES6-模板字符串</h2>
<p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<p>例子：
    // 字符串中嵌入变量
    let name = &quot;Bob&quot;;
    <code>Hello ${name}</code></p>
<h2 id="13-es6-">13.ES6-函数的扩展</h2>
<h3 id="1-">1.参数指定默认值</h3>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x = &quot;hello&quot;, y = &#39;World&#39;) {
  console.log(x, y);
}
</code></pre><p>注意：参数变量是默认声明的，所以不能用let或const再次声明。</p>
<pre><code>function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
</code></pre><h3 id="2-">2.箭头函数</h3>
<p><strong>1.ES6 允许使用“箭头”（=&gt;）定义函数</strong></p>
<pre><code>var f = (v) =&gt; { return v };

// 等同于
var f = function (v) {
  return v;
};
</code></pre><p><strong>2.如果箭头函数只有一个参数,可以省略小括号</strong></p>
<pre><code>var f = v =&gt; { return v };
</code></pre><p><strong>3.如果箭头函数 函数块 的值直接返回，可以省略大括号和return关键字</strong></p>
<pre><code>var f = v =&gt; v ;
</code></pre><p><strong>4.如果箭头函数需要直接返回对象，需要给函数块加上小括号</strong></p>
<pre><code>var f = v =&gt; ({ a: 1 }) ;
</code></pre><p><strong>5.箭头函数作用域</strong></p>
<pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
</code></pre><p><strong>6.注意</strong>
1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
2.不可以当作构造函数，也就是说，不可以使用new命令
3.不可以使用arguments对象，该对象在函数体内不存在</p>
<h2 id="14-node-js-">14.Node.js模块操作</h2>
<p><strong>1.使用require引入模块</strong></p>
<pre><code>var path = require(&#39;path&#39;);
console.log(path.resolve(__dirname))
</code></pre><p><strong>2.import命令的使用</strong></p>
<pre><code>import path from &quot;path&quot;;
console.log(path.resolve(__dirname))
</code></pre><p><strong>3.自己编写模块,export命令的使用</strong>
    // profile.js
    var firstName = &#39;Michael&#39;;
    var lastName = &#39;Jackson&#39;;
    var year = 1958;
    export {firstName, lastName, year};</p>
<pre><code>// 也可以写成
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

// main.js导入模块
import {firstName, lastName, year} from &#39;./profile.js&#39;;
console.log(firstName, lastName, year)
</code></pre><p><strong>4.export default 命令</strong>
为模块指定默认输出,可以不用指定的输出变量名</p>
<pre><code>// export-default.js
export default function () {
  console.log(&#39;foo&#39;);
}
</code></pre><p>export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</p>
<pre><code>import xxxx from &#39;./export-default.js&#39;;
</code></pre><p><strong>export和export default比较</strong>
    // print.js
    export function print() { 
        console.log(123)
    };</p>
<pre><code>// main.js
import {print} from &#39;print&#39;; // 输入

---------------------------------------------------

// print.js
export default function print() { // 输出
  console.log(123)
}

// main.js
import print from &#39;./print.js&#39;; // 输入
</code></pre><h2 id="-node-js-">【重点】Node.js操作本地文件</h2>
<p>1.读取本地文件</p>
<p>2.新建本地文件</p>
<p>3.写入本地文件</p>
<p>4.覆盖写入和新增写入</p>
<p>5.拷贝文件</p>
<p><strong>操作本地文件练习</strong></p>
<p>写入9*9乘法表</p>
<h2 id="-http-">请求HTTP服务器响应流程</h2>
<p><strong>客户端 - dns域名解析 - HTTP服务器</strong></p>
<p><img src="F:\广州传智前端-课程资料\课程-Node.js阶段\day-01\A-上课资料\images\7cc829d3gw1f3j8irkkr5j20qo0p0goe.jpg" alt=""></p>
<h2 id="-http-">【重点】构建HTTP服务器</h2>
<p>1.导入http模块
2.使用http.createServer创建服务器对象
3.服务器对象监听端口
4.服务器监听并响应请求</p>
<h2 id="-">参考资料</h2>
<p>【Nodejs的诞生】    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000</a></p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>